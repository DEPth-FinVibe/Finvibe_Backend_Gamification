---
description: 패키지 구조 컨벤션
alwaysApply: false
---
com.myco.orderingservice
  /boot                // 앱 실행, DI 조립, 설정
  /shared              // (정말 최소) 공통: 시간, ID, 에러, 트랜잭션 유틸 등
  /modules
    /catalog           // BC1
      /api             // 외부에 노출할 계약(REST, gRPC, 메시지 핸들러)
      /application     // 유스케이스(서비스), 트랜잭션 경계
      /domain          // 엔티티/밸류/도메인서비스/도메인이벤트
      /infra           // DB, 외부클라이언트, 메시지, 구현체
    /pricing           // BC2
      ...
    /fulfillment       // BC3
      ...


각 레이어 역할

api: 컨트롤러/핸들러 + 요청/응답 DTO (도메인 모델 노출 금지)

application: 유스케이스(커맨드/쿼리), 트랜잭션/권한/오케스트레이션

domain: 순수 도메인(규칙), 다만 개발 편의를 위해 JPA Entity로 직접 설계

infra: 외부 API 호출, 메시지 브로커 등 기술 구현

모듈 간 의존성 규칙

“모듈러 모놀리식”이 되려면 규칙을 박아야 함

원칙

다른 모듈의 domain을 직접 import 금지

모듈 A가 모듈 B를 써야 하면:

B가 api(또는 application)에 공개 인터페이스/DTO를 제공

A는 그것만 의존

즉:

허용: modules.order.application -> modules.catalog.api

비권장/금지: modules.order.domain -> modules.catalog.domain

공유(shared)는 “최소”

shared에 도메인을 넣기 시작하면 경계가 무너져.

OK: Clock, Result, DomainError, CorrelationId, 로깅/트레이싱 유틸

조심: User, Money, Address 같은 “비즈니스 의미”가 강한 것
(필요하면 각 BC 내부에 Money를 두거나, 정말 공통이면 “커널(Shared Kernel)”로 합의가 있어야 함)

추천 2) “내부 API” 패키지로 계약을 더 명확히

모듈 간 호출이 많아질 것 같으면, api를 외부/내부로 나눠서 의도를 드러내기도 해.

/modules/catalog
  /api
    /external   // 외부 클라이언트용 REST
    /internal   // 다른 모듈이 호출할 Port/DTO


DB/리포지토리 패키지 룰

각 모듈의 infra.persistence 아래에 자기 테이블/엔티티/리포지토리 두기

다른 모듈 테이블을 JPA 연관관계로 엮지 않기

조회가 필요하면

(1) 내부 API로 조회

(2) CQRS read-model/view를 별도로 두기(필요할 때)

“쪼개기” 대비 팁

나중에 모듈을 독립 마이크로서비스로 분리할 가능성이 있으면:

모듈 간 호출은 항상 “계약(인터페이스+DTO)”로만

이벤트 발행/구독 포인트를 application에 두기

모듈별 설정/DB 마이그레이션도 분리(예: flyway location을 모듈별로)